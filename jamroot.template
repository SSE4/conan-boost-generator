import modules ;

import project ;
rule project_find ( name : current-location )
{
    local caller = [ CALLER_MODULE ] ;
    module $(caller)
    {
        local name = $(1) ;
        if [ MATCH "([.][.][/][.][.]/.*/build)" : $(name) ]
        {
            name = [ MATCH "[.][.][/][.][.]/(.*)/build" : $(name) ] ;
            name = /boost/$(name) ;
        }
        return [ __project_find__ $(name) : $(2) ] ;
    }
}
IMPORT project : find : : __project_find__ ;
IMPORT $(__name__) : project_find : project : find ;
EXPORT project : find ;

import generate ;
import print ;
import build-system ;
import targets ;
import path ;

import boostcpp ;

path-constant BOOST_ROOT : . ;
constant BOOST_VERSION : {{{boost_version}}} ;
constant BOOST_JAMROOT_MODULE : $(__name__) ;

boostcpp.set-version $(BOOST_VERSION) ;

local DEP_INCLUDES = {{{deps.include_paths}}} ;
local LIBRARIES = {{{libraries}}} ;

project boost
:   requirements
    <define>BOOST_ALL_NO_LIB=1
    <tag>@$(__name__).tag
    <link>shared,<runtime-link>static:<build>no
    <toolset>como:<link>static
    <toolset>como-linux:<define>_GNU_SOURCE=1
    <include>$(DEP_INCLUDES)
    <include>$(LIBRARIES)/include
:   build-dir bin
:   default-build {{{variant}}}
    <target-os>{{{os}}}
    <address-model>{{{address_model}}}
    <architecture>{{{architecture}}}
;

rule tag ( name : type ? : property-set )
{
    return [ boostcpp.tag $(name) : $(type) : $(property-set) ] ;
}

rule boost-install ( libraries * )
{
    install stage : $(libraries) : <location>output ;
    module [ CALLER_MODULE ] { explicit stage ; }
}

module boostcpp
{
    IMPORT alias : alias : boostcpp : __alias__ ;
    rule alias ( name : sources * : requirements * : default-build * :
        usage-requirements * )
    {
        local LIBRARIES = {{{libraries}}} ;
        if $(sources) in libs/$(LIBRARIES)/build { sources = [ MATCH libs/(.*) : $(sources) ] ; }
        return [ __alias__ $(name) : $(sources) : $(requirements)
            : $(default-build) : $(usage-requirements) ] ;
    }
}

rule lib_target (
    name : sources * : requirements * : default-build * : usage-requirements * )
{
    local caller = [ CALLER_MODULE ] ;
    module $(caller)
    {
        local sources ;
        for source in $(2)
        {
            if [ MATCH "([/]boost[/][/])" : $(source) ]
            {
                s = [ MATCH "[/]boost[/][/](.*)" : $(source) ] ;
                s = /boost/$(source) ;
            }
            else if [ MATCH "([.][.][/][.][.]/.*/build)" : $(source) ]
            {
                source = [ MATCH "[.][.][/][.][.]/(.*)/build//(.*)" : $(source) ] ;
                source = /boost/$(source[1])//$(source[2]) ;
            }
            sources += $(source) ;
        }
        return [ __lib_target__ $(1) : $(sources) : $(3) : $(4) ] ;
    }
}
IMPORT : lib : : __lib_target__ ;
IMPORT $(__name__) : lib_target : : lib ;

local LIBRARIES_BUILD = ;
for local library in $(LIBRARIES)
{
    if [ path.exists $(library)/build ]
    {
        use-project /boost/$(library) : $(library)/build ;
        LIBRARIES_BUILD += $(library) ;
    }
}

boostcpp.declare-targets $(LIBRARIES_BUILD) ;

rule export-jamroot ( targets * : sources * : properties * )
{
    print.output $(targets[1]) ;
    print.text "import project ;" ;
    print.text "project /{{{name}}} ;" ;
    local dollar = "\$" ;
    for local library in {{{libraries}}}
    {
        print.text "project.register-id /boost/$(library) : $(dollar)(__name__) ;" ;
        print.text "lib boost_$(library) : : <name>boost_$(library) <search>. ;" ;
    }
}

make jamroot.jam : : @export-jamroot ;

install export-jamroot : jamroot.jam : <location>stage/lib ;

{{{deps_info}}}

rule post-build ( ok ? )
{
    if forward in [ modules.peek : top-level-targets ]
    {
        if $(ok)
        {
            ECHO "The {{{name}}} C++ Library was successfully built!" ;
        }
    }
}
IMPORT $(__name__) : post-build : : $(__name__).post-build ;
build-system.set-post-build-hook $(__name__).post-build ;
